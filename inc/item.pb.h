// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: item.proto

#ifndef PROTOBUF_item_2eproto__INCLUDED
#define PROTOBUF_item_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_item_2eproto();
void protobuf_AssignDesc_item_2eproto();
void protobuf_ShutdownFile_item_2eproto();

class Item;
class ItemSet;

enum Item_MajorType {
  Item_MajorType_MAJOR_TYPE_NORMAL = 0,
  Item_MajorType_MAJOR_TYPE_USABLE = 1,
  Item_MajorType_MAJOR_TYPE_EQUIP = 2,
  Item_MajorType_MAJOR_TYPE_VIRTUAL = 999
};
bool Item_MajorType_IsValid(int value);
const Item_MajorType Item_MajorType_MajorType_MIN = Item_MajorType_MAJOR_TYPE_NORMAL;
const Item_MajorType Item_MajorType_MajorType_MAX = Item_MajorType_MAJOR_TYPE_VIRTUAL;
const int Item_MajorType_MajorType_ARRAYSIZE = Item_MajorType_MajorType_MAX + 1;

enum Item_EffectType {
  Item_EffectType_EFFECT_NONE = 0,
  Item_EffectType_EFFECT_EXP = 1,
  Item_EffectType_EFFECT_GOLD = 2,
  Item_EffectType_EFFECT_MONEY = 3,
  Item_EffectType_EFFECT_HP = 11,
  Item_EffectType_EFFECT_ARMOR = 12,
  Item_EffectType_EFFECT_AD = 13,
  Item_EffectType_EFFECT_SPD = 14,
  Item_EffectType_EFFECT_PACKED = 999
};
bool Item_EffectType_IsValid(int value);
const Item_EffectType Item_EffectType_EffectType_MIN = Item_EffectType_EFFECT_NONE;
const Item_EffectType Item_EffectType_EffectType_MAX = Item_EffectType_EFFECT_PACKED;
const int Item_EffectType_EffectType_ARRAYSIZE = Item_EffectType_EffectType_MAX + 1;

enum Item_PayType {
  Item_PayType_PAY_GOLD = 1,
  Item_PayType_PAY_MOENY = 2
};
bool Item_PayType_IsValid(int value);
const Item_PayType Item_PayType_PayType_MIN = Item_PayType_PAY_GOLD;
const Item_PayType Item_PayType_PayType_MAX = Item_PayType_PAY_MOENY;
const int Item_PayType_PayType_ARRAYSIZE = Item_PayType_PayType_MAX + 1;

// ===================================================================

class Item : public ::google::protobuf::MessageLite {
 public:
  Item();
  virtual ~Item();

  Item(const Item& from);

  inline Item& operator=(const Item& from) {
    CopyFrom(from);
    return *this;
  }

  static const Item& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Item* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Item* other);

  // implements Message ----------------------------------------------

  Item* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Item& from);
  void MergeFrom(const Item& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Item_MajorType MajorType;
  static const MajorType MAJOR_TYPE_NORMAL = Item_MajorType_MAJOR_TYPE_NORMAL;
  static const MajorType MAJOR_TYPE_USABLE = Item_MajorType_MAJOR_TYPE_USABLE;
  static const MajorType MAJOR_TYPE_EQUIP = Item_MajorType_MAJOR_TYPE_EQUIP;
  static const MajorType MAJOR_TYPE_VIRTUAL = Item_MajorType_MAJOR_TYPE_VIRTUAL;
  static inline bool MajorType_IsValid(int value) {
    return Item_MajorType_IsValid(value);
  }
  static const MajorType MajorType_MIN =
    Item_MajorType_MajorType_MIN;
  static const MajorType MajorType_MAX =
    Item_MajorType_MajorType_MAX;
  static const int MajorType_ARRAYSIZE =
    Item_MajorType_MajorType_ARRAYSIZE;

  typedef Item_EffectType EffectType;
  static const EffectType EFFECT_NONE = Item_EffectType_EFFECT_NONE;
  static const EffectType EFFECT_EXP = Item_EffectType_EFFECT_EXP;
  static const EffectType EFFECT_GOLD = Item_EffectType_EFFECT_GOLD;
  static const EffectType EFFECT_MONEY = Item_EffectType_EFFECT_MONEY;
  static const EffectType EFFECT_HP = Item_EffectType_EFFECT_HP;
  static const EffectType EFFECT_ARMOR = Item_EffectType_EFFECT_ARMOR;
  static const EffectType EFFECT_AD = Item_EffectType_EFFECT_AD;
  static const EffectType EFFECT_SPD = Item_EffectType_EFFECT_SPD;
  static const EffectType EFFECT_PACKED = Item_EffectType_EFFECT_PACKED;
  static inline bool EffectType_IsValid(int value) {
    return Item_EffectType_IsValid(value);
  }
  static const EffectType EffectType_MIN =
    Item_EffectType_EffectType_MIN;
  static const EffectType EffectType_MAX =
    Item_EffectType_EffectType_MAX;
  static const int EffectType_ARRAYSIZE =
    Item_EffectType_EffectType_ARRAYSIZE;

  typedef Item_PayType PayType;
  static const PayType PAY_GOLD = Item_PayType_PAY_GOLD;
  static const PayType PAY_MOENY = Item_PayType_PAY_MOENY;
  static inline bool PayType_IsValid(int value) {
    return Item_PayType_IsValid(value);
  }
  static const PayType PayType_MIN =
    Item_PayType_PayType_MIN;
  static const PayType PayType_MAX =
    Item_PayType_PayType_MAX;
  static const int PayType_ARRAYSIZE =
    Item_PayType_PayType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .Identity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Identity& id() const;
  inline ::Identity* mutable_id();
  inline ::Identity* release_id();
  inline void set_allocated_id(::Identity* id);

  // optional int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional .Experience expr = 3;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 3;
  inline const ::Experience& expr() const;
  inline ::Experience* mutable_expr();
  inline ::Experience* release_expr();
  inline void set_allocated_expr(::Experience* expr);

  // optional int64 timelimit = 4;
  inline bool has_timelimit() const;
  inline void clear_timelimit();
  static const int kTimelimitFieldNumber = 4;
  inline ::google::protobuf::int64 timelimit() const;
  inline void set_timelimit(::google::protobuf::int64 value);

  // optional int32 subtype = 5;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubtypeFieldNumber = 5;
  inline ::google::protobuf::int32 subtype() const;
  inline void set_subtype(::google::protobuf::int32 value);

  // optional bytes customdata = 10;
  inline bool has_customdata() const;
  inline void clear_customdata();
  static const int kCustomdataFieldNumber = 10;
  inline const ::std::string& customdata() const;
  inline void set_customdata(const ::std::string& value);
  inline void set_customdata(const char* value);
  inline void set_customdata(const void* value, size_t size);
  inline ::std::string* mutable_customdata();
  inline ::std::string* release_customdata();
  inline void set_allocated_customdata(::std::string* customdata);

  // @@protoc_insertion_point(class_scope:Item)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_expr();
  inline void clear_has_expr();
  inline void set_has_timelimit();
  inline void clear_has_timelimit();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_customdata();
  inline void clear_has_customdata();

  ::Identity* id_;
  ::Experience* expr_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::int32 subtype_;
  ::google::protobuf::int64 timelimit_;
  ::std::string* customdata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_item_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_item_2eproto();
  #endif
  friend void protobuf_AssignDesc_item_2eproto();
  friend void protobuf_ShutdownFile_item_2eproto();

  void InitAsDefaultInstance();
  static Item* default_instance_;
};
// -------------------------------------------------------------------

class ItemSet : public ::google::protobuf::MessageLite {
 public:
  ItemSet();
  virtual ~ItemSet();

  ItemSet(const ItemSet& from);

  inline ItemSet& operator=(const ItemSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const ItemSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemSet* other);

  // implements Message ----------------------------------------------

  ItemSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemSet& from);
  void MergeFrom(const ItemSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Item items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::Item& items(int index) const;
  inline ::Item* mutable_items(int index);
  inline ::Item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Item >*
      mutable_items();

  // optional int32 maxid = 100;
  inline bool has_maxid() const;
  inline void clear_maxid();
  static const int kMaxidFieldNumber = 100;
  inline ::google::protobuf::int32 maxid() const;
  inline void set_maxid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ItemSet)
 private:
  inline void set_has_maxid();
  inline void clear_has_maxid();

  ::google::protobuf::RepeatedPtrField< ::Item > items_;
  ::google::protobuf::int32 maxid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_item_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_item_2eproto();
  #endif
  friend void protobuf_AssignDesc_item_2eproto();
  friend void protobuf_ShutdownFile_item_2eproto();

  void InitAsDefaultInstance();
  static ItemSet* default_instance_;
};
// ===================================================================


// ===================================================================

// Item

// optional .Identity id = 1;
inline bool Item::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Item::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Item::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Item::clear_id() {
  if (id_ != NULL) id_->::Identity::Clear();
  clear_has_id();
}
inline const ::Identity& Item::id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::Identity* Item::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Identity;
  return id_;
}
inline ::Identity* Item::release_id() {
  clear_has_id();
  ::Identity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Item::set_allocated_id(::Identity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional int32 num = 2;
inline bool Item::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Item::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Item::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Item::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 Item::num() const {
  return num_;
}
inline void Item::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional .Experience expr = 3;
inline bool Item::has_expr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Item::set_has_expr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Item::clear_has_expr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Item::clear_expr() {
  if (expr_ != NULL) expr_->::Experience::Clear();
  clear_has_expr();
}
inline const ::Experience& Item::expr() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return expr_ != NULL ? *expr_ : *default_instance().expr_;
#else
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
#endif
}
inline ::Experience* Item::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::Experience;
  return expr_;
}
inline ::Experience* Item::release_expr() {
  clear_has_expr();
  ::Experience* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void Item::set_allocated_expr(::Experience* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// optional int64 timelimit = 4;
inline bool Item::has_timelimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Item::set_has_timelimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Item::clear_has_timelimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Item::clear_timelimit() {
  timelimit_ = GOOGLE_LONGLONG(0);
  clear_has_timelimit();
}
inline ::google::protobuf::int64 Item::timelimit() const {
  return timelimit_;
}
inline void Item::set_timelimit(::google::protobuf::int64 value) {
  set_has_timelimit();
  timelimit_ = value;
}

// optional int32 subtype = 5;
inline bool Item::has_subtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Item::set_has_subtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Item::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Item::clear_subtype() {
  subtype_ = 0;
  clear_has_subtype();
}
inline ::google::protobuf::int32 Item::subtype() const {
  return subtype_;
}
inline void Item::set_subtype(::google::protobuf::int32 value) {
  set_has_subtype();
  subtype_ = value;
}

// optional bytes customdata = 10;
inline bool Item::has_customdata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Item::set_has_customdata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Item::clear_has_customdata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Item::clear_customdata() {
  if (customdata_ != &::google::protobuf::internal::kEmptyString) {
    customdata_->clear();
  }
  clear_has_customdata();
}
inline const ::std::string& Item::customdata() const {
  return *customdata_;
}
inline void Item::set_customdata(const ::std::string& value) {
  set_has_customdata();
  if (customdata_ == &::google::protobuf::internal::kEmptyString) {
    customdata_ = new ::std::string;
  }
  customdata_->assign(value);
}
inline void Item::set_customdata(const char* value) {
  set_has_customdata();
  if (customdata_ == &::google::protobuf::internal::kEmptyString) {
    customdata_ = new ::std::string;
  }
  customdata_->assign(value);
}
inline void Item::set_customdata(const void* value, size_t size) {
  set_has_customdata();
  if (customdata_ == &::google::protobuf::internal::kEmptyString) {
    customdata_ = new ::std::string;
  }
  customdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Item::mutable_customdata() {
  set_has_customdata();
  if (customdata_ == &::google::protobuf::internal::kEmptyString) {
    customdata_ = new ::std::string;
  }
  return customdata_;
}
inline ::std::string* Item::release_customdata() {
  clear_has_customdata();
  if (customdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customdata_;
    customdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Item::set_allocated_customdata(::std::string* customdata) {
  if (customdata_ != &::google::protobuf::internal::kEmptyString) {
    delete customdata_;
  }
  if (customdata) {
    set_has_customdata();
    customdata_ = customdata;
  } else {
    clear_has_customdata();
    customdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ItemSet

// repeated .Item items = 1;
inline int ItemSet::items_size() const {
  return items_.size();
}
inline void ItemSet::clear_items() {
  items_.Clear();
}
inline const ::Item& ItemSet::items(int index) const {
  return items_.Get(index);
}
inline ::Item* ItemSet::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::Item* ItemSet::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Item >&
ItemSet::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Item >*
ItemSet::mutable_items() {
  return &items_;
}

// optional int32 maxid = 100;
inline bool ItemSet::has_maxid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemSet::set_has_maxid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemSet::clear_has_maxid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemSet::clear_maxid() {
  maxid_ = 0;
  clear_has_maxid();
}
inline ::google::protobuf::int32 ItemSet::maxid() const {
  return maxid_;
}
inline void ItemSet::set_maxid(::google::protobuf::int32 value) {
  set_has_maxid();
  maxid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_item_2eproto__INCLUDED
