// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: battlemsg.proto

#ifndef PROTOBUF_battlemsg_2eproto__INCLUDED
#define PROTOBUF_battlemsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "role.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_battlemsg_2eproto();
void protobuf_AssignDesc_battlemsg_2eproto();
void protobuf_ShutdownFile_battlemsg_2eproto();

class BattleUnitIdxDef;
class BattleAction;
class BattleUnit;
class BattleTeam;
class BattleInitState;
class BattleInitBuff;
class BattleRound;
class BattleDetail;
class BattleResult;
class BattleRecord;

enum BattleUnitIdxDef_IdxDef {
  BattleUnitIdxDef_IdxDef_UNIT_IDX_ALIAS_ALL = 0,
  BattleUnitIdxDef_IdxDef_UNIT_IDX_ALIAS_HOME_TEAM = 1,
  BattleUnitIdxDef_IdxDef_UNIT_IDX_ALIAS_AWAY_TEAM = 2,
  BattleUnitIdxDef_IdxDef_UINT_IDX_HOME_BEGIN = 100,
  BattleUnitIdxDef_IdxDef_UNIT_IDX_AWAY_BEGIN = 200
};
bool BattleUnitIdxDef_IdxDef_IsValid(int value);
const BattleUnitIdxDef_IdxDef BattleUnitIdxDef_IdxDef_IdxDef_MIN = BattleUnitIdxDef_IdxDef_UNIT_IDX_ALIAS_ALL;
const BattleUnitIdxDef_IdxDef BattleUnitIdxDef_IdxDef_IdxDef_MAX = BattleUnitIdxDef_IdxDef_UNIT_IDX_AWAY_BEGIN;
const int BattleUnitIdxDef_IdxDef_IdxDef_ARRAYSIZE = BattleUnitIdxDef_IdxDef_IdxDef_MAX + 1;

enum BattleAction_BattleActionType {
  BattleAction_BattleActionType_ACTION_DMG = 1,
  BattleAction_BattleActionType_ACTION_CAST = 2,
  BattleAction_BattleActionType_ACTION_BUFF_BEGIN = 3,
  BattleAction_BattleActionType_ACTION_BUFF_END = 4,
  BattleAction_BattleActionType_ACTION_BECAST = 5,
  BattleAction_BattleActionType_ACTION_DIE = 99
};
bool BattleAction_BattleActionType_IsValid(int value);
const BattleAction_BattleActionType BattleAction_BattleActionType_BattleActionType_MIN = BattleAction_BattleActionType_ACTION_DMG;
const BattleAction_BattleActionType BattleAction_BattleActionType_BattleActionType_MAX = BattleAction_BattleActionType_ACTION_DIE;
const int BattleAction_BattleActionType_BattleActionType_ARRAYSIZE = BattleAction_BattleActionType_BattleActionType_MAX + 1;

// ===================================================================

class BattleUnitIdxDef : public ::google::protobuf::MessageLite {
 public:
  BattleUnitIdxDef();
  virtual ~BattleUnitIdxDef();

  BattleUnitIdxDef(const BattleUnitIdxDef& from);

  inline BattleUnitIdxDef& operator=(const BattleUnitIdxDef& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleUnitIdxDef& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleUnitIdxDef* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleUnitIdxDef* other);

  // implements Message ----------------------------------------------

  BattleUnitIdxDef* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleUnitIdxDef& from);
  void MergeFrom(const BattleUnitIdxDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BattleUnitIdxDef_IdxDef IdxDef;
  static const IdxDef UNIT_IDX_ALIAS_ALL = BattleUnitIdxDef_IdxDef_UNIT_IDX_ALIAS_ALL;
  static const IdxDef UNIT_IDX_ALIAS_HOME_TEAM = BattleUnitIdxDef_IdxDef_UNIT_IDX_ALIAS_HOME_TEAM;
  static const IdxDef UNIT_IDX_ALIAS_AWAY_TEAM = BattleUnitIdxDef_IdxDef_UNIT_IDX_ALIAS_AWAY_TEAM;
  static const IdxDef UINT_IDX_HOME_BEGIN = BattleUnitIdxDef_IdxDef_UINT_IDX_HOME_BEGIN;
  static const IdxDef UNIT_IDX_AWAY_BEGIN = BattleUnitIdxDef_IdxDef_UNIT_IDX_AWAY_BEGIN;
  static inline bool IdxDef_IsValid(int value) {
    return BattleUnitIdxDef_IdxDef_IsValid(value);
  }
  static const IdxDef IdxDef_MIN =
    BattleUnitIdxDef_IdxDef_IdxDef_MIN;
  static const IdxDef IdxDef_MAX =
    BattleUnitIdxDef_IdxDef_IdxDef_MAX;
  static const int IdxDef_ARRAYSIZE =
    BattleUnitIdxDef_IdxDef_IdxDef_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:BattleUnitIdxDef)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleUnitIdxDef* default_instance_;
};
// -------------------------------------------------------------------

class BattleAction : public ::google::protobuf::MessageLite {
 public:
  BattleAction();
  virtual ~BattleAction();

  BattleAction(const BattleAction& from);

  inline BattleAction& operator=(const BattleAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleAction* other);

  // implements Message ----------------------------------------------

  BattleAction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleAction& from);
  void MergeFrom(const BattleAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BattleAction_BattleActionType BattleActionType;
  static const BattleActionType ACTION_DMG = BattleAction_BattleActionType_ACTION_DMG;
  static const BattleActionType ACTION_CAST = BattleAction_BattleActionType_ACTION_CAST;
  static const BattleActionType ACTION_BUFF_BEGIN = BattleAction_BattleActionType_ACTION_BUFF_BEGIN;
  static const BattleActionType ACTION_BUFF_END = BattleAction_BattleActionType_ACTION_BUFF_END;
  static const BattleActionType ACTION_BECAST = BattleAction_BattleActionType_ACTION_BECAST;
  static const BattleActionType ACTION_DIE = BattleAction_BattleActionType_ACTION_DIE;
  static inline bool BattleActionType_IsValid(int value) {
    return BattleAction_BattleActionType_IsValid(value);
  }
  static const BattleActionType BattleActionType_MIN =
    BattleAction_BattleActionType_BattleActionType_MIN;
  static const BattleActionType BattleActionType_MAX =
    BattleAction_BattleActionType_BattleActionType_MAX;
  static const int BattleActionType_ARRAYSIZE =
    BattleAction_BattleActionType_BattleActionType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .BattleAction.BattleActionType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::BattleAction_BattleActionType type() const;
  inline void set_type(::BattleAction_BattleActionType value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 srcunitidx = 3;
  inline bool has_srcunitidx() const;
  inline void clear_srcunitidx();
  static const int kSrcunitidxFieldNumber = 3;
  inline ::google::protobuf::int32 srcunitidx() const;
  inline void set_srcunitidx(::google::protobuf::int32 value);

  // repeated int32 dstunitidxes = 4;
  inline int dstunitidxes_size() const;
  inline void clear_dstunitidxes();
  static const int kDstunitidxesFieldNumber = 4;
  inline ::google::protobuf::int32 dstunitidxes(int index) const;
  inline void set_dstunitidxes(int index, ::google::protobuf::int32 value);
  inline void add_dstunitidxes(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dstunitidxes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dstunitidxes();

  // repeated bytes params = 5;
  inline int params_size() const;
  inline void clear_params();
  static const int kParamsFieldNumber = 5;
  inline const ::std::string& params(int index) const;
  inline ::std::string* mutable_params(int index);
  inline void set_params(int index, const ::std::string& value);
  inline void set_params(int index, const char* value);
  inline void set_params(int index, const void* value, size_t size);
  inline ::std::string* add_params();
  inline void add_params(const ::std::string& value);
  inline void add_params(const char* value);
  inline void add_params(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();

  // repeated .BattleAction subactions = 6;
  inline int subactions_size() const;
  inline void clear_subactions();
  static const int kSubactionsFieldNumber = 6;
  inline const ::BattleAction& subactions(int index) const;
  inline ::BattleAction* mutable_subactions(int index);
  inline ::BattleAction* add_subactions();
  inline const ::google::protobuf::RepeatedPtrField< ::BattleAction >&
      subactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::BattleAction >*
      mutable_subactions();

  // @@protoc_insertion_point(class_scope:BattleAction)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_srcunitidx();
  inline void clear_has_srcunitidx();

  int type_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dstunitidxes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;
  ::google::protobuf::RepeatedPtrField< ::BattleAction > subactions_;
  ::google::protobuf::int32 srcunitidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleAction* default_instance_;
};
// -------------------------------------------------------------------

class BattleUnit : public ::google::protobuf::MessageLite {
 public:
  BattleUnit();
  virtual ~BattleUnit();

  BattleUnit(const BattleUnit& from);

  inline BattleUnit& operator=(const BattleUnit& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleUnit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleUnit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleUnit* other);

  // implements Message ----------------------------------------------

  BattleUnit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleUnit& from);
  void MergeFrom(const BattleUnit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 idx = 1;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 1;
  inline ::google::protobuf::int32 idx() const;
  inline void set_idx(::google::protobuf::int32 value);

  // optional int32 posIdx = 2;
  inline bool has_posidx() const;
  inline void clear_posidx();
  static const int kPosIdxFieldNumber = 2;
  inline ::google::protobuf::int32 posidx() const;
  inline void set_posidx(::google::protobuf::int32 value);

  // optional .Role roleinfo = 3;
  inline bool has_roleinfo() const;
  inline void clear_roleinfo();
  static const int kRoleinfoFieldNumber = 3;
  inline const ::Role& roleinfo() const;
  inline ::Role* mutable_roleinfo();
  inline ::Role* release_roleinfo();
  inline void set_allocated_roleinfo(::Role* roleinfo);

  // @@protoc_insertion_point(class_scope:BattleUnit)
 private:
  inline void set_has_idx();
  inline void clear_has_idx();
  inline void set_has_posidx();
  inline void clear_has_posidx();
  inline void set_has_roleinfo();
  inline void clear_has_roleinfo();

  ::google::protobuf::int32 idx_;
  ::google::protobuf::int32 posidx_;
  ::Role* roleinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleUnit* default_instance_;
};
// -------------------------------------------------------------------

class BattleTeam : public ::google::protobuf::MessageLite {
 public:
  BattleTeam();
  virtual ~BattleTeam();

  BattleTeam(const BattleTeam& from);

  inline BattleTeam& operator=(const BattleTeam& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleTeam& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleTeam* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleTeam* other);

  // implements Message ----------------------------------------------

  BattleTeam* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleTeam& from);
  void MergeFrom(const BattleTeam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BattleUnit units = 1;
  inline int units_size() const;
  inline void clear_units();
  static const int kUnitsFieldNumber = 1;
  inline const ::BattleUnit& units(int index) const;
  inline ::BattleUnit* mutable_units(int index);
  inline ::BattleUnit* add_units();
  inline const ::google::protobuf::RepeatedPtrField< ::BattleUnit >&
      units() const;
  inline ::google::protobuf::RepeatedPtrField< ::BattleUnit >*
      mutable_units();

  // @@protoc_insertion_point(class_scope:BattleTeam)
 private:

  ::google::protobuf::RepeatedPtrField< ::BattleUnit > units_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleTeam* default_instance_;
};
// -------------------------------------------------------------------

class BattleInitState : public ::google::protobuf::MessageLite {
 public:
  BattleInitState();
  virtual ~BattleInitState();

  BattleInitState(const BattleInitState& from);

  inline BattleInitState& operator=(const BattleInitState& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleInitState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleInitState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleInitState* other);

  // implements Message ----------------------------------------------

  BattleInitState* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleInitState& from);
  void MergeFrom(const BattleInitState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .BattleTeam hometeam = 1;
  inline bool has_hometeam() const;
  inline void clear_hometeam();
  static const int kHometeamFieldNumber = 1;
  inline const ::BattleTeam& hometeam() const;
  inline ::BattleTeam* mutable_hometeam();
  inline ::BattleTeam* release_hometeam();
  inline void set_allocated_hometeam(::BattleTeam* hometeam);

  // optional .BattleTeam awayteam = 2;
  inline bool has_awayteam() const;
  inline void clear_awayteam();
  static const int kAwayteamFieldNumber = 2;
  inline const ::BattleTeam& awayteam() const;
  inline ::BattleTeam* mutable_awayteam();
  inline ::BattleTeam* release_awayteam();
  inline void set_allocated_awayteam(::BattleTeam* awayteam);

  // @@protoc_insertion_point(class_scope:BattleInitState)
 private:
  inline void set_has_hometeam();
  inline void clear_has_hometeam();
  inline void set_has_awayteam();
  inline void clear_has_awayteam();

  ::BattleTeam* hometeam_;
  ::BattleTeam* awayteam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleInitState* default_instance_;
};
// -------------------------------------------------------------------

class BattleInitBuff : public ::google::protobuf::MessageLite {
 public:
  BattleInitBuff();
  virtual ~BattleInitBuff();

  BattleInitBuff(const BattleInitBuff& from);

  inline BattleInitBuff& operator=(const BattleInitBuff& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleInitBuff& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleInitBuff* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleInitBuff* other);

  // implements Message ----------------------------------------------

  BattleInitBuff* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleInitBuff& from);
  void MergeFrom(const BattleInitBuff& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .BattleAction homebuffs = 1;
  inline bool has_homebuffs() const;
  inline void clear_homebuffs();
  static const int kHomebuffsFieldNumber = 1;
  inline const ::BattleAction& homebuffs() const;
  inline ::BattleAction* mutable_homebuffs();
  inline ::BattleAction* release_homebuffs();
  inline void set_allocated_homebuffs(::BattleAction* homebuffs);

  // optional .BattleAction awaybuffs = 2;
  inline bool has_awaybuffs() const;
  inline void clear_awaybuffs();
  static const int kAwaybuffsFieldNumber = 2;
  inline const ::BattleAction& awaybuffs() const;
  inline ::BattleAction* mutable_awaybuffs();
  inline ::BattleAction* release_awaybuffs();
  inline void set_allocated_awaybuffs(::BattleAction* awaybuffs);

  // @@protoc_insertion_point(class_scope:BattleInitBuff)
 private:
  inline void set_has_homebuffs();
  inline void clear_has_homebuffs();
  inline void set_has_awaybuffs();
  inline void clear_has_awaybuffs();

  ::BattleAction* homebuffs_;
  ::BattleAction* awaybuffs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleInitBuff* default_instance_;
};
// -------------------------------------------------------------------

class BattleRound : public ::google::protobuf::MessageLite {
 public:
  BattleRound();
  virtual ~BattleRound();

  BattleRound(const BattleRound& from);

  inline BattleRound& operator=(const BattleRound& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleRound& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleRound* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleRound* other);

  // implements Message ----------------------------------------------

  BattleRound* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleRound& from);
  void MergeFrom(const BattleRound& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BattleAction actions = 1;
  inline int actions_size() const;
  inline void clear_actions();
  static const int kActionsFieldNumber = 1;
  inline const ::BattleAction& actions(int index) const;
  inline ::BattleAction* mutable_actions(int index);
  inline ::BattleAction* add_actions();
  inline const ::google::protobuf::RepeatedPtrField< ::BattleAction >&
      actions() const;
  inline ::google::protobuf::RepeatedPtrField< ::BattleAction >*
      mutable_actions();

  // @@protoc_insertion_point(class_scope:BattleRound)
 private:

  ::google::protobuf::RepeatedPtrField< ::BattleAction > actions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleRound* default_instance_;
};
// -------------------------------------------------------------------

class BattleDetail : public ::google::protobuf::MessageLite {
 public:
  BattleDetail();
  virtual ~BattleDetail();

  BattleDetail(const BattleDetail& from);

  inline BattleDetail& operator=(const BattleDetail& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleDetail& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleDetail* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleDetail* other);

  // implements Message ----------------------------------------------

  BattleDetail* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleDetail& from);
  void MergeFrom(const BattleDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BattleRound rounds = 1;
  inline int rounds_size() const;
  inline void clear_rounds();
  static const int kRoundsFieldNumber = 1;
  inline const ::BattleRound& rounds(int index) const;
  inline ::BattleRound* mutable_rounds(int index);
  inline ::BattleRound* add_rounds();
  inline const ::google::protobuf::RepeatedPtrField< ::BattleRound >&
      rounds() const;
  inline ::google::protobuf::RepeatedPtrField< ::BattleRound >*
      mutable_rounds();

  // @@protoc_insertion_point(class_scope:BattleDetail)
 private:

  ::google::protobuf::RepeatedPtrField< ::BattleRound > rounds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleDetail* default_instance_;
};
// -------------------------------------------------------------------

class BattleResult : public ::google::protobuf::MessageLite {
 public:
  BattleResult();
  virtual ~BattleResult();

  BattleResult(const BattleResult& from);

  inline BattleResult& operator=(const BattleResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleResult* other);

  // implements Message ----------------------------------------------

  BattleResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleResult& from);
  void MergeFrom(const BattleResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 win = 1;
  inline bool has_win() const;
  inline void clear_win();
  static const int kWinFieldNumber = 1;
  inline ::google::protobuf::int32 win() const;
  inline void set_win(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BattleResult)
 private:
  inline void set_has_win();
  inline void clear_has_win();

  ::google::protobuf::int32 win_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleResult* default_instance_;
};
// -------------------------------------------------------------------

class BattleRecord : public ::google::protobuf::MessageLite {
 public:
  BattleRecord();
  virtual ~BattleRecord();

  BattleRecord(const BattleRecord& from);

  inline BattleRecord& operator=(const BattleRecord& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleRecord& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleRecord* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleRecord* other);

  // implements Message ----------------------------------------------

  BattleRecord* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleRecord& from);
  void MergeFrom(const BattleRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional .BattleInitState initstate = 3;
  inline bool has_initstate() const;
  inline void clear_initstate();
  static const int kInitstateFieldNumber = 3;
  inline const ::BattleInitState& initstate() const;
  inline ::BattleInitState* mutable_initstate();
  inline ::BattleInitState* release_initstate();
  inline void set_allocated_initstate(::BattleInitState* initstate);

  // optional .BattleInitBuff initbuff = 4;
  inline bool has_initbuff() const;
  inline void clear_initbuff();
  static const int kInitbuffFieldNumber = 4;
  inline const ::BattleInitBuff& initbuff() const;
  inline ::BattleInitBuff* mutable_initbuff();
  inline ::BattleInitBuff* release_initbuff();
  inline void set_allocated_initbuff(::BattleInitBuff* initbuff);

  // optional .BattleDetail detail = 5;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 5;
  inline const ::BattleDetail& detail() const;
  inline ::BattleDetail* mutable_detail();
  inline ::BattleDetail* release_detail();
  inline void set_allocated_detail(::BattleDetail* detail);

  // optional .BattleResult result = 6;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 6;
  inline const ::BattleResult& result() const;
  inline ::BattleResult* mutable_result();
  inline ::BattleResult* release_result();
  inline void set_allocated_result(::BattleResult* result);

  // @@protoc_insertion_point(class_scope:BattleRecord)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_initstate();
  inline void clear_has_initstate();
  inline void set_has_initbuff();
  inline void clear_has_initbuff();
  inline void set_has_detail();
  inline void clear_has_detail();
  inline void set_has_result();
  inline void clear_has_result();

  ::std::string* type_;
  ::BattleInitState* initstate_;
  ::BattleInitBuff* initbuff_;
  ::BattleDetail* detail_;
  ::BattleResult* result_;
  ::google::protobuf::int32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_battlemsg_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_battlemsg_2eproto();
  #endif
  friend void protobuf_AssignDesc_battlemsg_2eproto();
  friend void protobuf_ShutdownFile_battlemsg_2eproto();

  void InitAsDefaultInstance();
  static BattleRecord* default_instance_;
};
// ===================================================================


// ===================================================================

// BattleUnitIdxDef

// -------------------------------------------------------------------

// BattleAction

// optional .BattleAction.BattleActionType type = 1;
inline bool BattleAction::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleAction::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleAction::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleAction::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::BattleAction_BattleActionType BattleAction::type() const {
  return static_cast< ::BattleAction_BattleActionType >(type_);
}
inline void BattleAction::set_type(::BattleAction_BattleActionType value) {
  assert(::BattleAction_BattleActionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 id = 2;
inline bool BattleAction::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleAction::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleAction::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleAction::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BattleAction::id() const {
  return id_;
}
inline void BattleAction::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 srcunitidx = 3;
inline bool BattleAction::has_srcunitidx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleAction::set_has_srcunitidx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleAction::clear_has_srcunitidx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleAction::clear_srcunitidx() {
  srcunitidx_ = 0;
  clear_has_srcunitidx();
}
inline ::google::protobuf::int32 BattleAction::srcunitidx() const {
  return srcunitidx_;
}
inline void BattleAction::set_srcunitidx(::google::protobuf::int32 value) {
  set_has_srcunitidx();
  srcunitidx_ = value;
}

// repeated int32 dstunitidxes = 4;
inline int BattleAction::dstunitidxes_size() const {
  return dstunitidxes_.size();
}
inline void BattleAction::clear_dstunitidxes() {
  dstunitidxes_.Clear();
}
inline ::google::protobuf::int32 BattleAction::dstunitidxes(int index) const {
  return dstunitidxes_.Get(index);
}
inline void BattleAction::set_dstunitidxes(int index, ::google::protobuf::int32 value) {
  dstunitidxes_.Set(index, value);
}
inline void BattleAction::add_dstunitidxes(::google::protobuf::int32 value) {
  dstunitidxes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BattleAction::dstunitidxes() const {
  return dstunitidxes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BattleAction::mutable_dstunitidxes() {
  return &dstunitidxes_;
}

// repeated bytes params = 5;
inline int BattleAction::params_size() const {
  return params_.size();
}
inline void BattleAction::clear_params() {
  params_.Clear();
}
inline const ::std::string& BattleAction::params(int index) const {
  return params_.Get(index);
}
inline ::std::string* BattleAction::mutable_params(int index) {
  return params_.Mutable(index);
}
inline void BattleAction::set_params(int index, const ::std::string& value) {
  params_.Mutable(index)->assign(value);
}
inline void BattleAction::set_params(int index, const char* value) {
  params_.Mutable(index)->assign(value);
}
inline void BattleAction::set_params(int index, const void* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleAction::add_params() {
  return params_.Add();
}
inline void BattleAction::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
}
inline void BattleAction::add_params(const char* value) {
  params_.Add()->assign(value);
}
inline void BattleAction::add_params(const void* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BattleAction::params() const {
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BattleAction::mutable_params() {
  return &params_;
}

// repeated .BattleAction subactions = 6;
inline int BattleAction::subactions_size() const {
  return subactions_.size();
}
inline void BattleAction::clear_subactions() {
  subactions_.Clear();
}
inline const ::BattleAction& BattleAction::subactions(int index) const {
  return subactions_.Get(index);
}
inline ::BattleAction* BattleAction::mutable_subactions(int index) {
  return subactions_.Mutable(index);
}
inline ::BattleAction* BattleAction::add_subactions() {
  return subactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BattleAction >&
BattleAction::subactions() const {
  return subactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::BattleAction >*
BattleAction::mutable_subactions() {
  return &subactions_;
}

// -------------------------------------------------------------------

// BattleUnit

// optional int32 idx = 1;
inline bool BattleUnit::has_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleUnit::set_has_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleUnit::clear_has_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleUnit::clear_idx() {
  idx_ = 0;
  clear_has_idx();
}
inline ::google::protobuf::int32 BattleUnit::idx() const {
  return idx_;
}
inline void BattleUnit::set_idx(::google::protobuf::int32 value) {
  set_has_idx();
  idx_ = value;
}

// optional int32 posIdx = 2;
inline bool BattleUnit::has_posidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleUnit::set_has_posidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleUnit::clear_has_posidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleUnit::clear_posidx() {
  posidx_ = 0;
  clear_has_posidx();
}
inline ::google::protobuf::int32 BattleUnit::posidx() const {
  return posidx_;
}
inline void BattleUnit::set_posidx(::google::protobuf::int32 value) {
  set_has_posidx();
  posidx_ = value;
}

// optional .Role roleinfo = 3;
inline bool BattleUnit::has_roleinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleUnit::set_has_roleinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleUnit::clear_has_roleinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleUnit::clear_roleinfo() {
  if (roleinfo_ != NULL) roleinfo_->::Role::Clear();
  clear_has_roleinfo();
}
inline const ::Role& BattleUnit::roleinfo() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return roleinfo_ != NULL ? *roleinfo_ : *default_instance().roleinfo_;
#else
  return roleinfo_ != NULL ? *roleinfo_ : *default_instance_->roleinfo_;
#endif
}
inline ::Role* BattleUnit::mutable_roleinfo() {
  set_has_roleinfo();
  if (roleinfo_ == NULL) roleinfo_ = new ::Role;
  return roleinfo_;
}
inline ::Role* BattleUnit::release_roleinfo() {
  clear_has_roleinfo();
  ::Role* temp = roleinfo_;
  roleinfo_ = NULL;
  return temp;
}
inline void BattleUnit::set_allocated_roleinfo(::Role* roleinfo) {
  delete roleinfo_;
  roleinfo_ = roleinfo;
  if (roleinfo) {
    set_has_roleinfo();
  } else {
    clear_has_roleinfo();
  }
}

// -------------------------------------------------------------------

// BattleTeam

// repeated .BattleUnit units = 1;
inline int BattleTeam::units_size() const {
  return units_.size();
}
inline void BattleTeam::clear_units() {
  units_.Clear();
}
inline const ::BattleUnit& BattleTeam::units(int index) const {
  return units_.Get(index);
}
inline ::BattleUnit* BattleTeam::mutable_units(int index) {
  return units_.Mutable(index);
}
inline ::BattleUnit* BattleTeam::add_units() {
  return units_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BattleUnit >&
BattleTeam::units() const {
  return units_;
}
inline ::google::protobuf::RepeatedPtrField< ::BattleUnit >*
BattleTeam::mutable_units() {
  return &units_;
}

// -------------------------------------------------------------------

// BattleInitState

// optional .BattleTeam hometeam = 1;
inline bool BattleInitState::has_hometeam() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleInitState::set_has_hometeam() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleInitState::clear_has_hometeam() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleInitState::clear_hometeam() {
  if (hometeam_ != NULL) hometeam_->::BattleTeam::Clear();
  clear_has_hometeam();
}
inline const ::BattleTeam& BattleInitState::hometeam() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return hometeam_ != NULL ? *hometeam_ : *default_instance().hometeam_;
#else
  return hometeam_ != NULL ? *hometeam_ : *default_instance_->hometeam_;
#endif
}
inline ::BattleTeam* BattleInitState::mutable_hometeam() {
  set_has_hometeam();
  if (hometeam_ == NULL) hometeam_ = new ::BattleTeam;
  return hometeam_;
}
inline ::BattleTeam* BattleInitState::release_hometeam() {
  clear_has_hometeam();
  ::BattleTeam* temp = hometeam_;
  hometeam_ = NULL;
  return temp;
}
inline void BattleInitState::set_allocated_hometeam(::BattleTeam* hometeam) {
  delete hometeam_;
  hometeam_ = hometeam;
  if (hometeam) {
    set_has_hometeam();
  } else {
    clear_has_hometeam();
  }
}

// optional .BattleTeam awayteam = 2;
inline bool BattleInitState::has_awayteam() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleInitState::set_has_awayteam() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleInitState::clear_has_awayteam() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleInitState::clear_awayteam() {
  if (awayteam_ != NULL) awayteam_->::BattleTeam::Clear();
  clear_has_awayteam();
}
inline const ::BattleTeam& BattleInitState::awayteam() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return awayteam_ != NULL ? *awayteam_ : *default_instance().awayteam_;
#else
  return awayteam_ != NULL ? *awayteam_ : *default_instance_->awayteam_;
#endif
}
inline ::BattleTeam* BattleInitState::mutable_awayteam() {
  set_has_awayteam();
  if (awayteam_ == NULL) awayteam_ = new ::BattleTeam;
  return awayteam_;
}
inline ::BattleTeam* BattleInitState::release_awayteam() {
  clear_has_awayteam();
  ::BattleTeam* temp = awayteam_;
  awayteam_ = NULL;
  return temp;
}
inline void BattleInitState::set_allocated_awayteam(::BattleTeam* awayteam) {
  delete awayteam_;
  awayteam_ = awayteam;
  if (awayteam) {
    set_has_awayteam();
  } else {
    clear_has_awayteam();
  }
}

// -------------------------------------------------------------------

// BattleInitBuff

// optional .BattleAction homebuffs = 1;
inline bool BattleInitBuff::has_homebuffs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleInitBuff::set_has_homebuffs() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleInitBuff::clear_has_homebuffs() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleInitBuff::clear_homebuffs() {
  if (homebuffs_ != NULL) homebuffs_->::BattleAction::Clear();
  clear_has_homebuffs();
}
inline const ::BattleAction& BattleInitBuff::homebuffs() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return homebuffs_ != NULL ? *homebuffs_ : *default_instance().homebuffs_;
#else
  return homebuffs_ != NULL ? *homebuffs_ : *default_instance_->homebuffs_;
#endif
}
inline ::BattleAction* BattleInitBuff::mutable_homebuffs() {
  set_has_homebuffs();
  if (homebuffs_ == NULL) homebuffs_ = new ::BattleAction;
  return homebuffs_;
}
inline ::BattleAction* BattleInitBuff::release_homebuffs() {
  clear_has_homebuffs();
  ::BattleAction* temp = homebuffs_;
  homebuffs_ = NULL;
  return temp;
}
inline void BattleInitBuff::set_allocated_homebuffs(::BattleAction* homebuffs) {
  delete homebuffs_;
  homebuffs_ = homebuffs;
  if (homebuffs) {
    set_has_homebuffs();
  } else {
    clear_has_homebuffs();
  }
}

// optional .BattleAction awaybuffs = 2;
inline bool BattleInitBuff::has_awaybuffs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleInitBuff::set_has_awaybuffs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleInitBuff::clear_has_awaybuffs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleInitBuff::clear_awaybuffs() {
  if (awaybuffs_ != NULL) awaybuffs_->::BattleAction::Clear();
  clear_has_awaybuffs();
}
inline const ::BattleAction& BattleInitBuff::awaybuffs() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return awaybuffs_ != NULL ? *awaybuffs_ : *default_instance().awaybuffs_;
#else
  return awaybuffs_ != NULL ? *awaybuffs_ : *default_instance_->awaybuffs_;
#endif
}
inline ::BattleAction* BattleInitBuff::mutable_awaybuffs() {
  set_has_awaybuffs();
  if (awaybuffs_ == NULL) awaybuffs_ = new ::BattleAction;
  return awaybuffs_;
}
inline ::BattleAction* BattleInitBuff::release_awaybuffs() {
  clear_has_awaybuffs();
  ::BattleAction* temp = awaybuffs_;
  awaybuffs_ = NULL;
  return temp;
}
inline void BattleInitBuff::set_allocated_awaybuffs(::BattleAction* awaybuffs) {
  delete awaybuffs_;
  awaybuffs_ = awaybuffs;
  if (awaybuffs) {
    set_has_awaybuffs();
  } else {
    clear_has_awaybuffs();
  }
}

// -------------------------------------------------------------------

// BattleRound

// repeated .BattleAction actions = 1;
inline int BattleRound::actions_size() const {
  return actions_.size();
}
inline void BattleRound::clear_actions() {
  actions_.Clear();
}
inline const ::BattleAction& BattleRound::actions(int index) const {
  return actions_.Get(index);
}
inline ::BattleAction* BattleRound::mutable_actions(int index) {
  return actions_.Mutable(index);
}
inline ::BattleAction* BattleRound::add_actions() {
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BattleAction >&
BattleRound::actions() const {
  return actions_;
}
inline ::google::protobuf::RepeatedPtrField< ::BattleAction >*
BattleRound::mutable_actions() {
  return &actions_;
}

// -------------------------------------------------------------------

// BattleDetail

// repeated .BattleRound rounds = 1;
inline int BattleDetail::rounds_size() const {
  return rounds_.size();
}
inline void BattleDetail::clear_rounds() {
  rounds_.Clear();
}
inline const ::BattleRound& BattleDetail::rounds(int index) const {
  return rounds_.Get(index);
}
inline ::BattleRound* BattleDetail::mutable_rounds(int index) {
  return rounds_.Mutable(index);
}
inline ::BattleRound* BattleDetail::add_rounds() {
  return rounds_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BattleRound >&
BattleDetail::rounds() const {
  return rounds_;
}
inline ::google::protobuf::RepeatedPtrField< ::BattleRound >*
BattleDetail::mutable_rounds() {
  return &rounds_;
}

// -------------------------------------------------------------------

// BattleResult

// optional int32 win = 1;
inline bool BattleResult::has_win() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleResult::set_has_win() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleResult::clear_has_win() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleResult::clear_win() {
  win_ = 0;
  clear_has_win();
}
inline ::google::protobuf::int32 BattleResult::win() const {
  return win_;
}
inline void BattleResult::set_win(::google::protobuf::int32 value) {
  set_has_win();
  win_ = value;
}

// -------------------------------------------------------------------

// BattleRecord

// optional int32 version = 1;
inline bool BattleRecord::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleRecord::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleRecord::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleRecord::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 BattleRecord::version() const {
  return version_;
}
inline void BattleRecord::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional string type = 2;
inline bool BattleRecord::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleRecord::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleRecord::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleRecord::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& BattleRecord::type() const {
  return *type_;
}
inline void BattleRecord::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void BattleRecord::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void BattleRecord::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BattleRecord::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* BattleRecord::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BattleRecord::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .BattleInitState initstate = 3;
inline bool BattleRecord::has_initstate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleRecord::set_has_initstate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleRecord::clear_has_initstate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleRecord::clear_initstate() {
  if (initstate_ != NULL) initstate_->::BattleInitState::Clear();
  clear_has_initstate();
}
inline const ::BattleInitState& BattleRecord::initstate() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initstate_ != NULL ? *initstate_ : *default_instance().initstate_;
#else
  return initstate_ != NULL ? *initstate_ : *default_instance_->initstate_;
#endif
}
inline ::BattleInitState* BattleRecord::mutable_initstate() {
  set_has_initstate();
  if (initstate_ == NULL) initstate_ = new ::BattleInitState;
  return initstate_;
}
inline ::BattleInitState* BattleRecord::release_initstate() {
  clear_has_initstate();
  ::BattleInitState* temp = initstate_;
  initstate_ = NULL;
  return temp;
}
inline void BattleRecord::set_allocated_initstate(::BattleInitState* initstate) {
  delete initstate_;
  initstate_ = initstate;
  if (initstate) {
    set_has_initstate();
  } else {
    clear_has_initstate();
  }
}

// optional .BattleInitBuff initbuff = 4;
inline bool BattleRecord::has_initbuff() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleRecord::set_has_initbuff() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleRecord::clear_has_initbuff() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleRecord::clear_initbuff() {
  if (initbuff_ != NULL) initbuff_->::BattleInitBuff::Clear();
  clear_has_initbuff();
}
inline const ::BattleInitBuff& BattleRecord::initbuff() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return initbuff_ != NULL ? *initbuff_ : *default_instance().initbuff_;
#else
  return initbuff_ != NULL ? *initbuff_ : *default_instance_->initbuff_;
#endif
}
inline ::BattleInitBuff* BattleRecord::mutable_initbuff() {
  set_has_initbuff();
  if (initbuff_ == NULL) initbuff_ = new ::BattleInitBuff;
  return initbuff_;
}
inline ::BattleInitBuff* BattleRecord::release_initbuff() {
  clear_has_initbuff();
  ::BattleInitBuff* temp = initbuff_;
  initbuff_ = NULL;
  return temp;
}
inline void BattleRecord::set_allocated_initbuff(::BattleInitBuff* initbuff) {
  delete initbuff_;
  initbuff_ = initbuff;
  if (initbuff) {
    set_has_initbuff();
  } else {
    clear_has_initbuff();
  }
}

// optional .BattleDetail detail = 5;
inline bool BattleRecord::has_detail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleRecord::set_has_detail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleRecord::clear_has_detail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleRecord::clear_detail() {
  if (detail_ != NULL) detail_->::BattleDetail::Clear();
  clear_has_detail();
}
inline const ::BattleDetail& BattleRecord::detail() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return detail_ != NULL ? *detail_ : *default_instance().detail_;
#else
  return detail_ != NULL ? *detail_ : *default_instance_->detail_;
#endif
}
inline ::BattleDetail* BattleRecord::mutable_detail() {
  set_has_detail();
  if (detail_ == NULL) detail_ = new ::BattleDetail;
  return detail_;
}
inline ::BattleDetail* BattleRecord::release_detail() {
  clear_has_detail();
  ::BattleDetail* temp = detail_;
  detail_ = NULL;
  return temp;
}
inline void BattleRecord::set_allocated_detail(::BattleDetail* detail) {
  delete detail_;
  detail_ = detail;
  if (detail) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
}

// optional .BattleResult result = 6;
inline bool BattleRecord::has_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleRecord::set_has_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleRecord::clear_has_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleRecord::clear_result() {
  if (result_ != NULL) result_->::BattleResult::Clear();
  clear_has_result();
}
inline const ::BattleResult& BattleRecord::result() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return result_ != NULL ? *result_ : *default_instance().result_;
#else
  return result_ != NULL ? *result_ : *default_instance_->result_;
#endif
}
inline ::BattleResult* BattleRecord::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::BattleResult;
  return result_;
}
inline ::BattleResult* BattleRecord::release_result() {
  clear_has_result();
  ::BattleResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void BattleRecord::set_allocated_result(::BattleResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_battlemsg_2eproto__INCLUDED
