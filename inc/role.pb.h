// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: role.proto

#ifndef PROTOBUF_role_2eproto__INCLUDED
#define PROTOBUF_role_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "common.pb.h"
#include "item.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_role_2eproto();
void protobuf_AssignDesc_role_2eproto();
void protobuf_ShutdownFile_role_2eproto();

class Equip;
class BattleSkill;
class BattleAttr;
class Role;
class RoleSet;

enum Equip_POSITION_IDX {
  Equip_POSITION_IDX_HELMET = 0,
  Equip_POSITION_IDX_ARMOR = 1,
  Equip_POSITION_IDX_WEAPON = 2,
  Equip_POSITION_IDX_AMULET = 3,
  Equip_POSITION_IDX_END = 4
};
bool Equip_POSITION_IDX_IsValid(int value);
const Equip_POSITION_IDX Equip_POSITION_IDX_POSITION_IDX_MIN = Equip_POSITION_IDX_HELMET;
const Equip_POSITION_IDX Equip_POSITION_IDX_POSITION_IDX_MAX = Equip_POSITION_IDX_END;
const int Equip_POSITION_IDX_POSITION_IDX_ARRAYSIZE = Equip_POSITION_IDX_POSITION_IDX_MAX + 1;

enum BattleSkill_SKILL_TYPE {
  BattleSkill_SKILL_TYPE_PHYSICAL_DAMAGE = 1
};
bool BattleSkill_SKILL_TYPE_IsValid(int value);
const BattleSkill_SKILL_TYPE BattleSkill_SKILL_TYPE_SKILL_TYPE_MIN = BattleSkill_SKILL_TYPE_PHYSICAL_DAMAGE;
const BattleSkill_SKILL_TYPE BattleSkill_SKILL_TYPE_SKILL_TYPE_MAX = BattleSkill_SKILL_TYPE_PHYSICAL_DAMAGE;
const int BattleSkill_SKILL_TYPE_SKILL_TYPE_ARRAYSIZE = BattleSkill_SKILL_TYPE_SKILL_TYPE_MAX + 1;

// ===================================================================

class Equip : public ::google::protobuf::MessageLite {
 public:
  Equip();
  virtual ~Equip();

  Equip(const Equip& from);

  inline Equip& operator=(const Equip& from) {
    CopyFrom(from);
    return *this;
  }

  static const Equip& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Equip* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Equip* other);

  // implements Message ----------------------------------------------

  Equip* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Equip& from);
  void MergeFrom(const Equip& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Equip_POSITION_IDX POSITION_IDX;
  static const POSITION_IDX HELMET = Equip_POSITION_IDX_HELMET;
  static const POSITION_IDX ARMOR = Equip_POSITION_IDX_ARMOR;
  static const POSITION_IDX WEAPON = Equip_POSITION_IDX_WEAPON;
  static const POSITION_IDX AMULET = Equip_POSITION_IDX_AMULET;
  static const POSITION_IDX END = Equip_POSITION_IDX_END;
  static inline bool POSITION_IDX_IsValid(int value) {
    return Equip_POSITION_IDX_IsValid(value);
  }
  static const POSITION_IDX POSITION_IDX_MIN =
    Equip_POSITION_IDX_POSITION_IDX_MIN;
  static const POSITION_IDX POSITION_IDX_MAX =
    Equip_POSITION_IDX_POSITION_IDX_MAX;
  static const int POSITION_IDX_ARRAYSIZE =
    Equip_POSITION_IDX_POSITION_IDX_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .Item items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::Item& items(int index) const;
  inline ::Item* mutable_items(int index);
  inline ::Item* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::Item >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::Item >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:Equip)
 private:

  ::google::protobuf::RepeatedPtrField< ::Item > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_role_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_role_2eproto();
  #endif
  friend void protobuf_AssignDesc_role_2eproto();
  friend void protobuf_ShutdownFile_role_2eproto();

  void InitAsDefaultInstance();
  static Equip* default_instance_;
};
// -------------------------------------------------------------------

class BattleSkill : public ::google::protobuf::MessageLite {
 public:
  BattleSkill();
  virtual ~BattleSkill();

  BattleSkill(const BattleSkill& from);

  inline BattleSkill& operator=(const BattleSkill& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleSkill& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleSkill* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleSkill* other);

  // implements Message ----------------------------------------------

  BattleSkill* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleSkill& from);
  void MergeFrom(const BattleSkill& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef BattleSkill_SKILL_TYPE SKILL_TYPE;
  static const SKILL_TYPE PHYSICAL_DAMAGE = BattleSkill_SKILL_TYPE_PHYSICAL_DAMAGE;
  static inline bool SKILL_TYPE_IsValid(int value) {
    return BattleSkill_SKILL_TYPE_IsValid(value);
  }
  static const SKILL_TYPE SKILL_TYPE_MIN =
    BattleSkill_SKILL_TYPE_SKILL_TYPE_MIN;
  static const SKILL_TYPE SKILL_TYPE_MAX =
    BattleSkill_SKILL_TYPE_SKILL_TYPE_MAX;
  static const int SKILL_TYPE_ARRAYSIZE =
    BattleSkill_SKILL_TYPE_SKILL_TYPE_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated int32 ids = 1;
  inline int ids_size() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 1;
  inline ::google::protobuf::int32 ids(int index) const;
  inline void set_ids(int index, ::google::protobuf::int32 value);
  inline void add_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ids();

  // @@protoc_insertion_point(class_scope:BattleSkill)
 private:

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_role_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_role_2eproto();
  #endif
  friend void protobuf_AssignDesc_role_2eproto();
  friend void protobuf_ShutdownFile_role_2eproto();

  void InitAsDefaultInstance();
  static BattleSkill* default_instance_;
};
// -------------------------------------------------------------------

class BattleAttr : public ::google::protobuf::MessageLite {
 public:
  BattleAttr();
  virtual ~BattleAttr();

  BattleAttr(const BattleAttr& from);

  inline BattleAttr& operator=(const BattleAttr& from) {
    CopyFrom(from);
    return *this;
  }

  static const BattleAttr& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BattleAttr* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BattleAttr* other);

  // implements Message ----------------------------------------------

  BattleAttr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BattleAttr& from);
  void MergeFrom(const BattleAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 hp = 1;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 1;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // optional int32 ad = 2;
  inline bool has_ad() const;
  inline void clear_ad();
  static const int kAdFieldNumber = 2;
  inline ::google::protobuf::int32 ad() const;
  inline void set_ad(::google::protobuf::int32 value);

  // optional int32 ap = 3;
  inline bool has_ap() const;
  inline void clear_ap();
  static const int kApFieldNumber = 3;
  inline ::google::protobuf::int32 ap() const;
  inline void set_ap(::google::protobuf::int32 value);

  // optional int32 arm = 4;
  inline bool has_arm() const;
  inline void clear_arm();
  static const int kArmFieldNumber = 4;
  inline ::google::protobuf::int32 arm() const;
  inline void set_arm(::google::protobuf::int32 value);

  // optional int32 mr = 5;
  inline bool has_mr() const;
  inline void clear_mr();
  static const int kMrFieldNumber = 5;
  inline ::google::protobuf::int32 mr() const;
  inline void set_mr(::google::protobuf::int32 value);

  // optional int32 ms = 6;
  inline bool has_ms() const;
  inline void clear_ms();
  static const int kMsFieldNumber = 6;
  inline ::google::protobuf::int32 ms() const;
  inline void set_ms(::google::protobuf::int32 value);

  // optional int32 as = 7;
  inline bool has_as() const;
  inline void clear_as();
  static const int kAsFieldNumber = 7;
  inline ::google::protobuf::int32 as() const;
  inline void set_as(::google::protobuf::int32 value);

  // optional int32 cr = 8;
  inline bool has_cr() const;
  inline void clear_cr();
  static const int kCrFieldNumber = 8;
  inline ::google::protobuf::int32 cr() const;
  inline void set_cr(::google::protobuf::int32 value);

  // optional int32 hr = 9;
  inline bool has_hr() const;
  inline void clear_hr();
  static const int kHrFieldNumber = 9;
  inline ::google::protobuf::int32 hr() const;
  inline void set_hr(::google::protobuf::int32 value);

  // optional int32 dr = 10;
  inline bool has_dr() const;
  inline void clear_dr();
  static const int kDrFieldNumber = 10;
  inline ::google::protobuf::int32 dr() const;
  inline void set_dr(::google::protobuf::int32 value);

  // optional int32 armigv = 11;
  inline bool has_armigv() const;
  inline void clear_armigv();
  static const int kArmigvFieldNumber = 11;
  inline ::google::protobuf::int32 armigv() const;
  inline void set_armigv(::google::protobuf::int32 value);

  // optional int32 armigr = 12;
  inline bool has_armigr() const;
  inline void clear_armigr();
  static const int kArmigrFieldNumber = 12;
  inline ::google::protobuf::int32 armigr() const;
  inline void set_armigr(::google::protobuf::int32 value);

  // optional int32 mrigv = 13;
  inline bool has_mrigv() const;
  inline void clear_mrigv();
  static const int kMrigvFieldNumber = 13;
  inline ::google::protobuf::int32 mrigv() const;
  inline void set_mrigv(::google::protobuf::int32 value);

  // optional int32 mrigr = 14;
  inline bool has_mrigr() const;
  inline void clear_mrigr();
  static const int kMrigrFieldNumber = 14;
  inline ::google::protobuf::int32 mrigr() const;
  inline void set_mrigr(::google::protobuf::int32 value);

  // optional int32 energy = 15;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 15;
  inline ::google::protobuf::int32 energy() const;
  inline void set_energy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BattleAttr)
 private:
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_ad();
  inline void clear_has_ad();
  inline void set_has_ap();
  inline void clear_has_ap();
  inline void set_has_arm();
  inline void clear_has_arm();
  inline void set_has_mr();
  inline void clear_has_mr();
  inline void set_has_ms();
  inline void clear_has_ms();
  inline void set_has_as();
  inline void clear_has_as();
  inline void set_has_cr();
  inline void clear_has_cr();
  inline void set_has_hr();
  inline void clear_has_hr();
  inline void set_has_dr();
  inline void clear_has_dr();
  inline void set_has_armigv();
  inline void clear_has_armigv();
  inline void set_has_armigr();
  inline void clear_has_armigr();
  inline void set_has_mrigv();
  inline void clear_has_mrigv();
  inline void set_has_mrigr();
  inline void clear_has_mrigr();
  inline void set_has_energy();
  inline void clear_has_energy();

  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 ad_;
  ::google::protobuf::int32 ap_;
  ::google::protobuf::int32 arm_;
  ::google::protobuf::int32 mr_;
  ::google::protobuf::int32 ms_;
  ::google::protobuf::int32 as_;
  ::google::protobuf::int32 cr_;
  ::google::protobuf::int32 hr_;
  ::google::protobuf::int32 dr_;
  ::google::protobuf::int32 armigv_;
  ::google::protobuf::int32 armigr_;
  ::google::protobuf::int32 mrigv_;
  ::google::protobuf::int32 mrigr_;
  ::google::protobuf::int32 energy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_role_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_role_2eproto();
  #endif
  friend void protobuf_AssignDesc_role_2eproto();
  friend void protobuf_ShutdownFile_role_2eproto();

  void InitAsDefaultInstance();
  static BattleAttr* default_instance_;
};
// -------------------------------------------------------------------

class Role : public ::google::protobuf::MessageLite {
 public:
  Role();
  virtual ~Role();

  Role(const Role& from);

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }

  static const Role& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Role* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Role* other);

  // implements Message ----------------------------------------------

  Role* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Role& from);
  void MergeFrom(const Role& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Identity id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::Identity& id() const;
  inline ::Identity* mutable_id();
  inline ::Identity* release_id();
  inline void set_allocated_id(::Identity* id);

  // optional .Experience expr = 2;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 2;
  inline const ::Experience& expr() const;
  inline ::Experience* mutable_expr();
  inline ::Experience* release_expr();
  inline void set_allocated_expr(::Experience* expr);

  // optional .BattleAttr battr = 3;
  inline bool has_battr() const;
  inline void clear_battr();
  static const int kBattrFieldNumber = 3;
  inline const ::BattleAttr& battr() const;
  inline ::BattleAttr* mutable_battr();
  inline ::BattleAttr* release_battr();
  inline void set_allocated_battr(::BattleAttr* battr);

  // optional int32 ismain = 4;
  inline bool has_ismain() const;
  inline void clear_ismain();
  static const int kIsmainFieldNumber = 4;
  inline ::google::protobuf::int32 ismain() const;
  inline void set_ismain(::google::protobuf::int32 value);

  // optional int32 showtype = 5;
  inline bool has_showtype() const;
  inline void clear_showtype();
  static const int kShowtypeFieldNumber = 5;
  inline ::google::protobuf::int32 showtype() const;
  inline void set_showtype(::google::protobuf::int32 value);

  // optional .Equip equip = 6;
  inline bool has_equip() const;
  inline void clear_equip();
  static const int kEquipFieldNumber = 6;
  inline const ::Equip& equip() const;
  inline ::Equip* mutable_equip();
  inline ::Equip* release_equip();
  inline void set_allocated_equip(::Equip* equip);

  // optional .BattleSkill skill = 7;
  inline bool has_skill() const;
  inline void clear_skill();
  static const int kSkillFieldNumber = 7;
  inline const ::BattleSkill& skill() const;
  inline ::BattleSkill* mutable_skill();
  inline ::BattleSkill* release_skill();
  inline void set_allocated_skill(::BattleSkill* skill);

  // optional int32 hireflag = 100;
  inline bool has_hireflag() const;
  inline void clear_hireflag();
  static const int kHireflagFieldNumber = 100;
  inline ::google::protobuf::int32 hireflag() const;
  inline void set_hireflag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Role)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_expr();
  inline void clear_has_expr();
  inline void set_has_battr();
  inline void clear_has_battr();
  inline void set_has_ismain();
  inline void clear_has_ismain();
  inline void set_has_showtype();
  inline void clear_has_showtype();
  inline void set_has_equip();
  inline void clear_has_equip();
  inline void set_has_skill();
  inline void clear_has_skill();
  inline void set_has_hireflag();
  inline void clear_has_hireflag();

  ::Identity* id_;
  ::Experience* expr_;
  ::BattleAttr* battr_;
  ::google::protobuf::int32 ismain_;
  ::google::protobuf::int32 showtype_;
  ::Equip* equip_;
  ::BattleSkill* skill_;
  ::google::protobuf::int32 hireflag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_role_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_role_2eproto();
  #endif
  friend void protobuf_AssignDesc_role_2eproto();
  friend void protobuf_ShutdownFile_role_2eproto();

  void InitAsDefaultInstance();
  static Role* default_instance_;
};
// -------------------------------------------------------------------

class RoleSet : public ::google::protobuf::MessageLite {
 public:
  RoleSet();
  virtual ~RoleSet();

  RoleSet(const RoleSet& from);

  inline RoleSet& operator=(const RoleSet& from) {
    CopyFrom(from);
    return *this;
  }

  static const RoleSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RoleSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RoleSet* other);

  // implements Message ----------------------------------------------

  RoleSet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RoleSet& from);
  void MergeFrom(const RoleSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Role roles = 1;
  inline int roles_size() const;
  inline void clear_roles();
  static const int kRolesFieldNumber = 1;
  inline const ::Role& roles(int index) const;
  inline ::Role* mutable_roles(int index);
  inline ::Role* add_roles();
  inline const ::google::protobuf::RepeatedPtrField< ::Role >&
      roles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Role >*
      mutable_roles();

  // optional int32 mainroleidx = 2;
  inline bool has_mainroleidx() const;
  inline void clear_mainroleidx();
  static const int kMainroleidxFieldNumber = 2;
  inline ::google::protobuf::int32 mainroleidx() const;
  inline void set_mainroleidx(::google::protobuf::int32 value);

  // repeated .Identity battlelist = 3;
  inline int battlelist_size() const;
  inline void clear_battlelist();
  static const int kBattlelistFieldNumber = 3;
  inline const ::Identity& battlelist(int index) const;
  inline ::Identity* mutable_battlelist(int index);
  inline ::Identity* add_battlelist();
  inline const ::google::protobuf::RepeatedPtrField< ::Identity >&
      battlelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::Identity >*
      mutable_battlelist();

  // optional int32 battlelistmax = 4;
  inline bool has_battlelistmax() const;
  inline void clear_battlelistmax();
  static const int kBattlelistmaxFieldNumber = 4;
  inline ::google::protobuf::int32 battlelistmax() const;
  inline void set_battlelistmax(::google::protobuf::int32 value);

  // repeated .Role shopRoles = 5;
  inline int shoproles_size() const;
  inline void clear_shoproles();
  static const int kShopRolesFieldNumber = 5;
  inline const ::Role& shoproles(int index) const;
  inline ::Role* mutable_shoproles(int index);
  inline ::Role* add_shoproles();
  inline const ::google::protobuf::RepeatedPtrField< ::Role >&
      shoproles() const;
  inline ::google::protobuf::RepeatedPtrField< ::Role >*
      mutable_shoproles();

  // optional int32 maxid = 100;
  inline bool has_maxid() const;
  inline void clear_maxid();
  static const int kMaxidFieldNumber = 100;
  inline ::google::protobuf::int32 maxid() const;
  inline void set_maxid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RoleSet)
 private:
  inline void set_has_mainroleidx();
  inline void clear_has_mainroleidx();
  inline void set_has_battlelistmax();
  inline void clear_has_battlelistmax();
  inline void set_has_maxid();
  inline void clear_has_maxid();

  ::google::protobuf::RepeatedPtrField< ::Role > roles_;
  ::google::protobuf::RepeatedPtrField< ::Identity > battlelist_;
  ::google::protobuf::int32 mainroleidx_;
  ::google::protobuf::int32 battlelistmax_;
  ::google::protobuf::RepeatedPtrField< ::Role > shoproles_;
  ::google::protobuf::int32 maxid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_role_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_role_2eproto();
  #endif
  friend void protobuf_AssignDesc_role_2eproto();
  friend void protobuf_ShutdownFile_role_2eproto();

  void InitAsDefaultInstance();
  static RoleSet* default_instance_;
};
// ===================================================================


// ===================================================================

// Equip

// repeated .Item items = 1;
inline int Equip::items_size() const {
  return items_.size();
}
inline void Equip::clear_items() {
  items_.Clear();
}
inline const ::Item& Equip::items(int index) const {
  return items_.Get(index);
}
inline ::Item* Equip::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::Item* Equip::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Item >&
Equip::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::Item >*
Equip::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// BattleSkill

// repeated int32 ids = 1;
inline int BattleSkill::ids_size() const {
  return ids_.size();
}
inline void BattleSkill::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::int32 BattleSkill::ids(int index) const {
  return ids_.Get(index);
}
inline void BattleSkill::set_ids(int index, ::google::protobuf::int32 value) {
  ids_.Set(index, value);
}
inline void BattleSkill::add_ids(::google::protobuf::int32 value) {
  ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BattleSkill::ids() const {
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BattleSkill::mutable_ids() {
  return &ids_;
}

// -------------------------------------------------------------------

// BattleAttr

// optional int32 hp = 1;
inline bool BattleAttr::has_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BattleAttr::set_has_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BattleAttr::clear_has_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BattleAttr::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 BattleAttr::hp() const {
  return hp_;
}
inline void BattleAttr::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
}

// optional int32 ad = 2;
inline bool BattleAttr::has_ad() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BattleAttr::set_has_ad() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BattleAttr::clear_has_ad() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BattleAttr::clear_ad() {
  ad_ = 0;
  clear_has_ad();
}
inline ::google::protobuf::int32 BattleAttr::ad() const {
  return ad_;
}
inline void BattleAttr::set_ad(::google::protobuf::int32 value) {
  set_has_ad();
  ad_ = value;
}

// optional int32 ap = 3;
inline bool BattleAttr::has_ap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BattleAttr::set_has_ap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BattleAttr::clear_has_ap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BattleAttr::clear_ap() {
  ap_ = 0;
  clear_has_ap();
}
inline ::google::protobuf::int32 BattleAttr::ap() const {
  return ap_;
}
inline void BattleAttr::set_ap(::google::protobuf::int32 value) {
  set_has_ap();
  ap_ = value;
}

// optional int32 arm = 4;
inline bool BattleAttr::has_arm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BattleAttr::set_has_arm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BattleAttr::clear_has_arm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BattleAttr::clear_arm() {
  arm_ = 0;
  clear_has_arm();
}
inline ::google::protobuf::int32 BattleAttr::arm() const {
  return arm_;
}
inline void BattleAttr::set_arm(::google::protobuf::int32 value) {
  set_has_arm();
  arm_ = value;
}

// optional int32 mr = 5;
inline bool BattleAttr::has_mr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BattleAttr::set_has_mr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BattleAttr::clear_has_mr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BattleAttr::clear_mr() {
  mr_ = 0;
  clear_has_mr();
}
inline ::google::protobuf::int32 BattleAttr::mr() const {
  return mr_;
}
inline void BattleAttr::set_mr(::google::protobuf::int32 value) {
  set_has_mr();
  mr_ = value;
}

// optional int32 ms = 6;
inline bool BattleAttr::has_ms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BattleAttr::set_has_ms() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BattleAttr::clear_has_ms() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BattleAttr::clear_ms() {
  ms_ = 0;
  clear_has_ms();
}
inline ::google::protobuf::int32 BattleAttr::ms() const {
  return ms_;
}
inline void BattleAttr::set_ms(::google::protobuf::int32 value) {
  set_has_ms();
  ms_ = value;
}

// optional int32 as = 7;
inline bool BattleAttr::has_as() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BattleAttr::set_has_as() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BattleAttr::clear_has_as() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BattleAttr::clear_as() {
  as_ = 0;
  clear_has_as();
}
inline ::google::protobuf::int32 BattleAttr::as() const {
  return as_;
}
inline void BattleAttr::set_as(::google::protobuf::int32 value) {
  set_has_as();
  as_ = value;
}

// optional int32 cr = 8;
inline bool BattleAttr::has_cr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BattleAttr::set_has_cr() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BattleAttr::clear_has_cr() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BattleAttr::clear_cr() {
  cr_ = 0;
  clear_has_cr();
}
inline ::google::protobuf::int32 BattleAttr::cr() const {
  return cr_;
}
inline void BattleAttr::set_cr(::google::protobuf::int32 value) {
  set_has_cr();
  cr_ = value;
}

// optional int32 hr = 9;
inline bool BattleAttr::has_hr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BattleAttr::set_has_hr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BattleAttr::clear_has_hr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BattleAttr::clear_hr() {
  hr_ = 0;
  clear_has_hr();
}
inline ::google::protobuf::int32 BattleAttr::hr() const {
  return hr_;
}
inline void BattleAttr::set_hr(::google::protobuf::int32 value) {
  set_has_hr();
  hr_ = value;
}

// optional int32 dr = 10;
inline bool BattleAttr::has_dr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BattleAttr::set_has_dr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BattleAttr::clear_has_dr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BattleAttr::clear_dr() {
  dr_ = 0;
  clear_has_dr();
}
inline ::google::protobuf::int32 BattleAttr::dr() const {
  return dr_;
}
inline void BattleAttr::set_dr(::google::protobuf::int32 value) {
  set_has_dr();
  dr_ = value;
}

// optional int32 armigv = 11;
inline bool BattleAttr::has_armigv() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BattleAttr::set_has_armigv() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BattleAttr::clear_has_armigv() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BattleAttr::clear_armigv() {
  armigv_ = 0;
  clear_has_armigv();
}
inline ::google::protobuf::int32 BattleAttr::armigv() const {
  return armigv_;
}
inline void BattleAttr::set_armigv(::google::protobuf::int32 value) {
  set_has_armigv();
  armigv_ = value;
}

// optional int32 armigr = 12;
inline bool BattleAttr::has_armigr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BattleAttr::set_has_armigr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BattleAttr::clear_has_armigr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BattleAttr::clear_armigr() {
  armigr_ = 0;
  clear_has_armigr();
}
inline ::google::protobuf::int32 BattleAttr::armigr() const {
  return armigr_;
}
inline void BattleAttr::set_armigr(::google::protobuf::int32 value) {
  set_has_armigr();
  armigr_ = value;
}

// optional int32 mrigv = 13;
inline bool BattleAttr::has_mrigv() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BattleAttr::set_has_mrigv() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BattleAttr::clear_has_mrigv() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BattleAttr::clear_mrigv() {
  mrigv_ = 0;
  clear_has_mrigv();
}
inline ::google::protobuf::int32 BattleAttr::mrigv() const {
  return mrigv_;
}
inline void BattleAttr::set_mrigv(::google::protobuf::int32 value) {
  set_has_mrigv();
  mrigv_ = value;
}

// optional int32 mrigr = 14;
inline bool BattleAttr::has_mrigr() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BattleAttr::set_has_mrigr() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BattleAttr::clear_has_mrigr() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BattleAttr::clear_mrigr() {
  mrigr_ = 0;
  clear_has_mrigr();
}
inline ::google::protobuf::int32 BattleAttr::mrigr() const {
  return mrigr_;
}
inline void BattleAttr::set_mrigr(::google::protobuf::int32 value) {
  set_has_mrigr();
  mrigr_ = value;
}

// optional int32 energy = 15;
inline bool BattleAttr::has_energy() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BattleAttr::set_has_energy() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BattleAttr::clear_has_energy() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BattleAttr::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline ::google::protobuf::int32 BattleAttr::energy() const {
  return energy_;
}
inline void BattleAttr::set_energy(::google::protobuf::int32 value) {
  set_has_energy();
  energy_ = value;
}

// -------------------------------------------------------------------

// Role

// optional .Identity id = 1;
inline bool Role::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Role::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Role::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Role::clear_id() {
  if (id_ != NULL) id_->::Identity::Clear();
  clear_has_id();
}
inline const ::Identity& Role::id() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return id_ != NULL ? *id_ : *default_instance().id_;
#else
  return id_ != NULL ? *id_ : *default_instance_->id_;
#endif
}
inline ::Identity* Role::mutable_id() {
  set_has_id();
  if (id_ == NULL) id_ = new ::Identity;
  return id_;
}
inline ::Identity* Role::release_id() {
  clear_has_id();
  ::Identity* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Role::set_allocated_id(::Identity* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
}

// optional .Experience expr = 2;
inline bool Role::has_expr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Role::set_has_expr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Role::clear_has_expr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Role::clear_expr() {
  if (expr_ != NULL) expr_->::Experience::Clear();
  clear_has_expr();
}
inline const ::Experience& Role::expr() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return expr_ != NULL ? *expr_ : *default_instance().expr_;
#else
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
#endif
}
inline ::Experience* Role::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::Experience;
  return expr_;
}
inline ::Experience* Role::release_expr() {
  clear_has_expr();
  ::Experience* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void Role::set_allocated_expr(::Experience* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// optional .BattleAttr battr = 3;
inline bool Role::has_battr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Role::set_has_battr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Role::clear_has_battr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Role::clear_battr() {
  if (battr_ != NULL) battr_->::BattleAttr::Clear();
  clear_has_battr();
}
inline const ::BattleAttr& Role::battr() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return battr_ != NULL ? *battr_ : *default_instance().battr_;
#else
  return battr_ != NULL ? *battr_ : *default_instance_->battr_;
#endif
}
inline ::BattleAttr* Role::mutable_battr() {
  set_has_battr();
  if (battr_ == NULL) battr_ = new ::BattleAttr;
  return battr_;
}
inline ::BattleAttr* Role::release_battr() {
  clear_has_battr();
  ::BattleAttr* temp = battr_;
  battr_ = NULL;
  return temp;
}
inline void Role::set_allocated_battr(::BattleAttr* battr) {
  delete battr_;
  battr_ = battr;
  if (battr) {
    set_has_battr();
  } else {
    clear_has_battr();
  }
}

// optional int32 ismain = 4;
inline bool Role::has_ismain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Role::set_has_ismain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Role::clear_has_ismain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Role::clear_ismain() {
  ismain_ = 0;
  clear_has_ismain();
}
inline ::google::protobuf::int32 Role::ismain() const {
  return ismain_;
}
inline void Role::set_ismain(::google::protobuf::int32 value) {
  set_has_ismain();
  ismain_ = value;
}

// optional int32 showtype = 5;
inline bool Role::has_showtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Role::set_has_showtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Role::clear_has_showtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Role::clear_showtype() {
  showtype_ = 0;
  clear_has_showtype();
}
inline ::google::protobuf::int32 Role::showtype() const {
  return showtype_;
}
inline void Role::set_showtype(::google::protobuf::int32 value) {
  set_has_showtype();
  showtype_ = value;
}

// optional .Equip equip = 6;
inline bool Role::has_equip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Role::set_has_equip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Role::clear_has_equip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Role::clear_equip() {
  if (equip_ != NULL) equip_->::Equip::Clear();
  clear_has_equip();
}
inline const ::Equip& Role::equip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return equip_ != NULL ? *equip_ : *default_instance().equip_;
#else
  return equip_ != NULL ? *equip_ : *default_instance_->equip_;
#endif
}
inline ::Equip* Role::mutable_equip() {
  set_has_equip();
  if (equip_ == NULL) equip_ = new ::Equip;
  return equip_;
}
inline ::Equip* Role::release_equip() {
  clear_has_equip();
  ::Equip* temp = equip_;
  equip_ = NULL;
  return temp;
}
inline void Role::set_allocated_equip(::Equip* equip) {
  delete equip_;
  equip_ = equip;
  if (equip) {
    set_has_equip();
  } else {
    clear_has_equip();
  }
}

// optional .BattleSkill skill = 7;
inline bool Role::has_skill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Role::set_has_skill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Role::clear_has_skill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Role::clear_skill() {
  if (skill_ != NULL) skill_->::BattleSkill::Clear();
  clear_has_skill();
}
inline const ::BattleSkill& Role::skill() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return skill_ != NULL ? *skill_ : *default_instance().skill_;
#else
  return skill_ != NULL ? *skill_ : *default_instance_->skill_;
#endif
}
inline ::BattleSkill* Role::mutable_skill() {
  set_has_skill();
  if (skill_ == NULL) skill_ = new ::BattleSkill;
  return skill_;
}
inline ::BattleSkill* Role::release_skill() {
  clear_has_skill();
  ::BattleSkill* temp = skill_;
  skill_ = NULL;
  return temp;
}
inline void Role::set_allocated_skill(::BattleSkill* skill) {
  delete skill_;
  skill_ = skill;
  if (skill) {
    set_has_skill();
  } else {
    clear_has_skill();
  }
}

// optional int32 hireflag = 100;
inline bool Role::has_hireflag() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Role::set_has_hireflag() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Role::clear_has_hireflag() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Role::clear_hireflag() {
  hireflag_ = 0;
  clear_has_hireflag();
}
inline ::google::protobuf::int32 Role::hireflag() const {
  return hireflag_;
}
inline void Role::set_hireflag(::google::protobuf::int32 value) {
  set_has_hireflag();
  hireflag_ = value;
}

// -------------------------------------------------------------------

// RoleSet

// repeated .Role roles = 1;
inline int RoleSet::roles_size() const {
  return roles_.size();
}
inline void RoleSet::clear_roles() {
  roles_.Clear();
}
inline const ::Role& RoleSet::roles(int index) const {
  return roles_.Get(index);
}
inline ::Role* RoleSet::mutable_roles(int index) {
  return roles_.Mutable(index);
}
inline ::Role* RoleSet::add_roles() {
  return roles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Role >&
RoleSet::roles() const {
  return roles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Role >*
RoleSet::mutable_roles() {
  return &roles_;
}

// optional int32 mainroleidx = 2;
inline bool RoleSet::has_mainroleidx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleSet::set_has_mainroleidx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleSet::clear_has_mainroleidx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleSet::clear_mainroleidx() {
  mainroleidx_ = 0;
  clear_has_mainroleidx();
}
inline ::google::protobuf::int32 RoleSet::mainroleidx() const {
  return mainroleidx_;
}
inline void RoleSet::set_mainroleidx(::google::protobuf::int32 value) {
  set_has_mainroleidx();
  mainroleidx_ = value;
}

// repeated .Identity battlelist = 3;
inline int RoleSet::battlelist_size() const {
  return battlelist_.size();
}
inline void RoleSet::clear_battlelist() {
  battlelist_.Clear();
}
inline const ::Identity& RoleSet::battlelist(int index) const {
  return battlelist_.Get(index);
}
inline ::Identity* RoleSet::mutable_battlelist(int index) {
  return battlelist_.Mutable(index);
}
inline ::Identity* RoleSet::add_battlelist() {
  return battlelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Identity >&
RoleSet::battlelist() const {
  return battlelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::Identity >*
RoleSet::mutable_battlelist() {
  return &battlelist_;
}

// optional int32 battlelistmax = 4;
inline bool RoleSet::has_battlelistmax() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoleSet::set_has_battlelistmax() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoleSet::clear_has_battlelistmax() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoleSet::clear_battlelistmax() {
  battlelistmax_ = 0;
  clear_has_battlelistmax();
}
inline ::google::protobuf::int32 RoleSet::battlelistmax() const {
  return battlelistmax_;
}
inline void RoleSet::set_battlelistmax(::google::protobuf::int32 value) {
  set_has_battlelistmax();
  battlelistmax_ = value;
}

// repeated .Role shopRoles = 5;
inline int RoleSet::shoproles_size() const {
  return shoproles_.size();
}
inline void RoleSet::clear_shoproles() {
  shoproles_.Clear();
}
inline const ::Role& RoleSet::shoproles(int index) const {
  return shoproles_.Get(index);
}
inline ::Role* RoleSet::mutable_shoproles(int index) {
  return shoproles_.Mutable(index);
}
inline ::Role* RoleSet::add_shoproles() {
  return shoproles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Role >&
RoleSet::shoproles() const {
  return shoproles_;
}
inline ::google::protobuf::RepeatedPtrField< ::Role >*
RoleSet::mutable_shoproles() {
  return &shoproles_;
}

// optional int32 maxid = 100;
inline bool RoleSet::has_maxid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoleSet::set_has_maxid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoleSet::clear_has_maxid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoleSet::clear_maxid() {
  maxid_ = 0;
  clear_has_maxid();
}
inline ::google::protobuf::int32 RoleSet::maxid() const {
  return maxid_;
}
inline void RoleSet::set_maxid(::google::protobuf::int32 value) {
  set_has_maxid();
  maxid_ = value;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_role_2eproto__INCLUDED
